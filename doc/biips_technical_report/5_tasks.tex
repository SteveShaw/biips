\chapter{To do}
\label{todo}

\section{Tasks}


\begin{enumerate}
 \item Exceptions handling
 \item Add distributions, functions, node samplers, tests, etc.
 \item BUGS language compiler: \\
  See section \ref{jags_compiler} for a study of JAGS compiler and its re-usability.
 \item Text Interface
 \item Replace SMCTC
 \item GPU\footnote{Graphic Processing Unit} Parallelization GPU using CUDA\footnote{Compute Unified Device Architecture}: \\
We will use CUDA to parallelize the particles mutation step. Important performance growths for SMC algorithms have been observed \cite{lee_utility_2009}. Indeed, the mutation step follows the SIMD\footnote{Same Instruction, Multiple Data} framework which is perfectly suited for GPU parallelization. We already have a desktop computer equipped with a NVidia GeForce GTX 460 GPU. This device is compatible with CUDA 2.1 which supports C++.\\
This task is not a priority as the functionality of the software comes before its performance in our objectives. However, this remains a marketing argument. A CUDA training course is planned on November, 9th.
 \item Graphical Interface
 \item Web site
 \item Port to other platform configurations (Windows, Mac)
 \item Technical report, scientific article
\end{enumerate}


\section{JAGS compiler}
\label{jags_compiler}

\paragraph{}
JAGS uses a scanner generated by Flex in the \texttt{scanner.cc} source file. The latter was generated from the \texttt{scanner.ll} definition file. See annex \ref{bisonflex} for more details about Flex\footnote{Fast Lexical analyzer} and Bison.

\paragraph{}
This scanner is used by the parser generated by Bison in the \texttt{parser.cc} source file, from the \texttt{parser.yy} grammar definition file. This source code defines a \texttt{parse\_bugs} function which analyzes the file describing a graphical model in BUGS language.

\paragraph{}
The aim of the actions defined in the grammar is to create a \texttt{ParseTree} object. Then a \texttt{Compiler} object is responsible for transforming it in a \texttt{BUGSModel} object. The latter is the one which will contain the node instances of the graphical model.

\begin{figure}[h!]
\begin{center}
\tikzstyle{input}=[rectangle, rounded corners,
                                    thick,
                                    text width=2.5cm,
                                    draw=blue!80,
                                    fill=blue!20,
                                    text centered,
                                    font=\large,
                                    ]
\tikzstyle{processing}=[rectangle, rounded corners,
                                    thick,
                                    text width=2.5cm,
                                    draw=green!80,
                                    fill=green!20,
                                    text centered,
                                    font=\large,
                                    ]
\tikzstyle{output}=[rectangle, rounded corners,
                                                thick,
                                                text width=2.5cm,
                                                draw=orange!80,
                                                fill=orange!25,
                                                text centered,
                                    font=\large,]
\begin{tikzpicture}[node distance=3.5cm,auto,>=latex']
\node (code) [input]   {BUGS language model};
\node (parser)   [processing,right of= code] {\texttt{parse\_bugs}};
\node (parsetree)   [output,right of= parser] {\texttt{ParseTree}};
\node (compiler)   [processing,right of=parsetree] {\texttt{Compiler}};
\node (model)   [output,right of=compiler] {\texttt{BUGSModel}};
 \path[->] (code) edge[thick] (parser);
 \path[->] (parser) edge[thick] (parsetree);
 \path[->] (parsetree) edge[thick] (compiler);
 \path[->] (compiler) edge[thick] (model);
\end{tikzpicture}
\label{fig:briques}
\caption{JAGS: Graphical model compilation process}
\end{center}
\end{figure}


\subsection{Re-usability of the ParseTree output}
The \texttt{ParseTree} class is completely independent of the rest of JAGS code, hence we can directly use it to build a \biips{} model.

\paragraph{}
A \texttt{ParseTree} object represents a BUGS language definition. Its \textquotedblleft class\textquotedblright{} is defined by a \texttt{TreeClass} member
\begin{lstlisting}
enum TreeClass { 
    P_VAR, P_RANGE, P_BOUNDS, P_DENSITY, P_LINK, P_COUNTER, 
    P_VALUE, P_STOCHREL, P_DETRMREL, P_FOR,  P_FUNCTION, P_RELATIONS,
    P_VECTOR, P_ARRAY, P_DIM, P_LENGTH, P_SUBSET
};
\end{lstlisting}

It also has a name (for \verb=P_VAR=, \verb=P_COUNTER=, \verb=P_FUNCTION=, \verb=P_DISTRIBUTION=, \verb=P_LINK=, or \verb=P_ARRAY= \textquotedblleft class\textquotedblright{}), a value (for  \verb=P_VALUE= \textquotedblleft class\textquotedblright{}), parameters (which are other \texttt{ParseTree} objects) to which it takes ownership, its line number in the model definition. Consequently, there exist a top-level \texttt{ParseTree} object that owns all the others.

\paragraph{}
Those parts of the code are completely isolated from the rest and are, hence, easily reusable. These are the parts of JAGS code we could reuse in \biips{}:
\begin{itemize}
 \item \texttt{src/lib/compiler/scanner.cc}
 \item \texttt{src/lib/compiler/parser.cc}
 \item \texttt{src/lib/compiler/remap.h}
 \item \texttt{src/lib/compiler/parser.h}
 \item \texttt{src/lib/compiler/parser\_extra.h}
 \item \texttt{src/lib/compiler/ParseTree.cc}
 \item \texttt{src/include/compiler/ParseTree.h}
\end{itemize} 

\paragraph{}
We would therefore reprogram the creation of \biips{} objects from the \texttt{ParseTree} object (\textit{i.e.} the \texttt{Compiler} class).


\subsection{Re-usability of the Compiler class code}
It would be ideal to be able to reuse the \texttt{Compiler} class (1135 lines) to generate a \biips{} model instead of a \texttt{BUGSModel} JAGS object. But this part of the code is wholly dependent of the rest of JAGS code, which makes its re-usability more complicated. We can however take ideas on it.

