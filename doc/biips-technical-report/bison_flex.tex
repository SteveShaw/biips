\chapter{Flex and Bison}
\label{bisonflex}

A compiler is composed of a scanner (lexical analyzer) and a parser (syntactic analyzer). Both programs can be generated by tools such as:
\begin {itemize}
 \item Flex (GPL), a free implementation of Lex, a lexical analyzer generator.
 \item Bison (LGPL\footnote{GNU Lesser General Public License}), a free implementation of Yacc\footnote{Yet another compiler compiler}, a parser generator.
\end {itemize}

\section{The lexical analyzer}
Parses the source text into tokens defined by regular expressions.

\paragraph{Example :} C function divided into tokens
\begin{quote}
\verb=int            /*= keyword 'int' \verb=*/= \\
\verb=square (int x) /*= identifier, open-paren, keyword 'int', identifier, close-paren \verb=*/= \\
\verb={              /*= open-brace *\verb=*/= \\
\verb=return x * x;  /*= keyword 'return', identifier, asterisk, identifier, semicolon \verb=*/= \\
\verb=}              /*= close-brace \verb=*/= 
\end{quote}

\paragraph{}
The description of the scanner is in the form of pairs of regular expressions and C code, called rules. Flex generates as output a C source file that defines a routine \texttt{yylex()}. It analyzes the occurrences of regular expressions of its input. At each detection, the corresponding C code is executed.


\section{The syntactic analyzer}
Reads a sequence of tokens and decides whether it corresponds to a syntax defined by the grammar.

\paragraph{}
The grammar is composed of symbols:
\begin{itemize}
\item nonterminal symbols (or groupings), conventionally represented by a lowercase identifier. \eg{} : \texttt{expr}, \texttt{stmt}, \ldots
\item terminal symbols (or token types), represented by
  \begin{itemize}
  \item an uppercase identifier. \eg{} : \texttt{INTEGER}, \texttt{IDENTIFIER}, \texttt{IF}, \texttt{RETURN}, \ldots
  \item a C character constant. \eg{} : \texttt{'('}, \texttt{')'}, \texttt{'+'}, \ldots
  \item a constant C string.
  \end{itemize}
\end{itemize}

Each nonterminal symbol must match a rule.

\paragraph{Example :} C \texttt{return} statement rule
\begin{quote}
\begin{verbatim}
stmt: RETURN expr ';'
      ;
\end{verbatim}
\end{quote}

\paragraph{}
Each grammar rule is assigned an action, \ie{} a set of instructions to be executed when the C syntax is identified. These actions are written in braces after the rule.

\paragraph{Example :} Rule stating that an expression may be the sum of two subexpressions
\begin{quote}
\begin{verbatim}
expr: expr '+' expr { $$ = $1 + $3; }
      ;
\end{verbatim}
\end{quote}

\paragraph{}
Here, the \texttt {\$\$}, \texttt{\$1} and \texttt{\$3} signs represent the semantic values of the sum expression, and the two sub-expressions.

\paragraph{}
Bison generates source C (or C++) code of the parser from a grammar file definition. The code defines a function \texttt{yyparse} which implements this grammar. The Bison grammar file take the general form:
\begin{quote}
\begin{verbatim}
%{
Prologue
%}
Bison declarations
%%
Grammar rules
%%
Epilogue
\end{verbatim}
\end{quote}

\paragraph{}
The prologue declares types and variables used in the actions, we can also write preprocessor commands such as \texttt{\#include}. The lexical analyzer \texttt{yylex} and the error printer \texttt{yyerror} must be declared here.

\paragraph{}
The Bison declarations declare the names of the particular terminal and nonterminal symbols.

\paragraph{}
The grammar rules define how to construct each nonterminal symbol from its parts.

\paragraph{}
The epilogue can contain any code you want to use. Often the definitions of functions declared in the prologue go here.
