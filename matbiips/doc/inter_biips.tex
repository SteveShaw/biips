\documentclass[11pt]{article}
\usepackage[english]{babel}
\usepackage[latin1]{inputenc}
\usepackage[dvips]{graphicx}
\usepackage{pstricks}
\usepackage{epsfig}
\usepackage{a4wide}
\usepackage{listings}
\usepackage{relsize}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.8,0.8,0.8}
\definecolor{mauve}{rgb}{0.58,0,0.82}
\newcommand{\biips}{{\bf Biips\ }{}}
\newcommand{\matlab}{{\bf MATLAB\ }{}}
\lstset{ %
  language=matlab,
  framerule=0pt,
  basicstyle=\relsize{-2}\ttfamily,  % the size of the fonts that are used for the code
  backgroundcolor=\color{gray},  % choose the background color. You must add \usepackage{color}
  showspaces=false,               % show spaces adding particular underscores
  showstringspaces=false,         % underline spaces within strings
  showtabs=false,                 % show tabs within strings adding particular underscores
  %frame=single,                   % adds a frame around the code
  rulecolor=\color{black},        % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. commens (green here))
  breakatwhitespace=false,        % sets if automatic breaks should only happen at whitespace
  keywordstyle=\color{blue},      % keyword style
  commentstyle=\color{dkgreen},   % comment style
  stringstyle=\color{mauve}
}




\begin{document}

\begin{center}
{\Huge Documentation of internal functions of the MatBiips interface}
\end{center}

\tableofcontents


\section{introduction}

  to call the Biips function in MATLAB,  

\section{make\_console}
 \begin{lstlisting}
   p = inter_biips('make_console')
 \end{lstlisting}
   
   \texttt{MAKE\_CONSOLE}  creates a new console and returns the id of the console in the global table of console. It
   is strongly recommended to store the number of the console in a variable, to be able later to communicate with Biips trough that
   console

\section{clear\_console}

 \begin{lstlisting}
   inter_biips('clear_console', id)
 \end{lstlisting}

  \texttt{CLEAR\_CONSOLE} suppress the console with the given \texttt{id} and free the memory associated

\section{clear\_all\_console}
 
 \begin{lstlisting}
   inter_biips('clear_all_console')
 \end{lstlisting}

  \texttt{CLEAR\_ALL\_CONSOLE} suppress all the consoles and free memory

\section{check\_model}

 \begin{lstlisting}
   inter_biips('check_model', id, filename)
 \end{lstlisting}
  
 \texttt{CHECK\_MODEL} verifies that the model given in the \texttt{filename} (with extension .bug) is consistent and associate it to the console \texttt{id}

\section{compile\_model}

 \begin{lstlisting}
   inter_biips('compile_model', id, vars, sample_data, seed) 
 \end{lstlisting}
   \begin{description}
   \setlength{\baselineskip}{0.1\baselineskip}
     \item[\texttt{id}]: the number of the console
     \item[\texttt{vars}]: a struct containing variables as fields, and the values in the model as values.
     \item[\texttt{sample\_data}]: a boolean flag indicating if data is given or sampled following the \texttt{data} section in the bug file
     \item[\texttt{seed}]: value of the seed used for random number generation
   
   \end{description}

   \texttt{COMPILE\_MODEL} compile the model previously furnished by the \texttt{CHECK\_MODEL} function. You can set up values of variables of 
   the model.


\section{get\_data}
   
 \begin{lstlisting}
   data = inter_biips('get_data', id) 
 \end{lstlisting}
 
  \texttt{GET\_DATA} retrieves all the data linked to a consoled with \texttt{id} and put it in the return value.


\section{load\_module}
 
 \begin{lstlisting}
   ok = inter_biips('load_module', name)
 \end{lstlisting}

  \texttt{LOAD\_MODULE} load the module \texttt{name} in Biips. Currently, it only works with \texttt{'basemod'} module. A 
  boolean flag is return if the operation is successful.

\section{verbosity}
 
 \begin{lstlisting}
  inter_biips('verbosity', level) 
 \end{lstlisting}

  \texttt{VERBOSITY} set the verbosity level of biips. \texttt{level} must belong to the set $\{0,1,2\}$

\section{get\_variables\_names}

 \begin{lstlisting}
  names = inter_biips('get_variable_names', id)
 \end{lstlisting}

 \texttt{GET\_VARIABLE\_NAMES} retrieves the names of variables of current model of the console \texttt{id} . the return value \texttt{names}
 is a cell of strings containing the names of variables

\section{set\_default\_monitors}

 \begin{lstlisting}
  names = inter_biips('set_default_monitors', id)
 \end{lstlisting}

 \texttt{SET\_DEFAULT\_MONITORS} set up the default filters for backward smoothing step for console model \texttt{id}

\section{set\_filter\_monitors}
 \begin{lstlisting}
  inter_biips('set_filter_monitors', id, monitored_vars, lower, upper )
 \end{lstlisting}
   
   \begin{description}
   \setlength{\baselineskip}{0.1\baselineskip}
     \item[\texttt{id}]: the number of the console
     \item[\texttt{monitored\_vars}]: cell containing strings for variables to be monitored
     \item[\texttt{lower}]: cell containing lower bound for range monitoring
     \item[\texttt{upper}]: cell containing upper bound for range monitoring 
   
   \end{description}

   \texttt{SET\_FILTER\_MONITORS} sets which variables must be monitored in the model. For instance to monitor x[1:10,1], one can use
 \begin{lstlisting}
  inter_biips('set_filter_monitors', id, {'x'} ,  {1,1} , {10,1} )
 \end{lstlisting}

\section{set\_gen\_tree\_smooth\_monitors}

 \begin{lstlisting}
  inter_biips('set_gen_tree_smooth_monitors', id, smooth_monitored_vars, lower, upper )
 \end{lstlisting}

   \begin{description}
   \setlength{\baselineskip}{0.1\baselineskip}
     \item[\texttt{id}]: the number of the console
     \item[\texttt{smooth\_monitored\_vars}]: cell containing strings for variables to be smooth monitored
     \item[\texttt{lower}]: cell containing lower bound for range smooth monitoring
     \item[\texttt{upper}]: cell containing upper bound for range smooth monitoring 
   
   \end{description}

   \texttt{SET\_GEN\_TREE\_SMOOTH\_MONITORS} sets which variables must be smoothly monitored in the model. For instance to smoothly monitor x[1:10,1], one can use
 \begin{lstlisting}
  inter_biips('set_gen_tree_smooth_monitors', id, {'x'} ,  {1,1} , {10,1} )
 \end{lstlisting}


\section{set\_backward\_smooth\_monitors}

 \begin{lstlisting}
  inter_biips('set_backward_smooth_monitors', id, bw_smooth_monitored_vars, lower, upper )
 \end{lstlisting}

   \begin{description}
     \item[\texttt{id}]: the number of the console
     \item[\texttt{bw\_smooth\_monitored\_vars}]: cell containing strings for variables to be backward smoothly monitored
     \item[\texttt{lower}]: cell containing lower bound for range smooth monitoring
     \item[\texttt{upper}]: cell containing upper bound for range smooth monitoring 
   
   \end{description}

   \texttt{SET\_BACKWARD\_SMOOTH\_MONITORS} sets which variables must be backward smoothly monitored in the model. For instance to backward smoothly monitor x[1:10,1], one can use
 \begin{lstlisting}
  inter_biips('set_backward_smooth_monitors', id, {'x'} ,  {1,1} , {10,1} )
 \end{lstlisting}

\section{build\_smc\_sampler}

 \begin{lstlisting}
  inter_biips('build_smc_sampler', id, prior_flag)
 \end{lstlisting}
  \texttt{BUILD\_SMC\_SAMPLER} builds the smc sampler associated to \texttt{id} console setting up possibly the prior method for sampling (\texttt{prior\_flag})

\section{is\_sampler\_built}

 \begin{lstlisting}
  ok = inter_biips('is_sampler_built', id)
 \end{lstlisting}
  \texttt{IS\_SAMPLER\_BUILT} returns the \texttt{ok} flag to check if sampler is built
\section{run\_smc\_sampler}

 \begin{lstlisting}
   ok = inter_biips('run_smc_sampler', id, nb_part, seed, ess_threshold, resample_type)
 \end{lstlisting}
 
   \begin{description}
     \item[\texttt{id}]: the number of the console
     \item[\texttt{nb\_part}]: number of particles 
     \item[\texttt{seed}]: seed for random number generator
     \item[\texttt{ess\_threshold}]: threshold value for the Effective Sample Size
     \item[\texttt{resample\_type}]: string belonging to \texttt{ 'stratified', 'systematic', 'residual', 'multinomial' } 
   
   \end{description}

  \texttt{RUN\_SMC\_SAMPLER} run the SMC with \texttt{nb\_part} particules. One can select the resampling method using \texttt{resample\_type}
  \section{get\_log\_norm\_const}

 \begin{lstlisting}
  log_norm = inter_biips('get_log_norm_const', id )
 \end{lstlisting}
 \texttt{GET\_LOG\_NORM\_CONST} returns the log normalizing constant relative to the console \texttt{id}

 \section{get\_filter\_monitors}

 \begin{lstlisting}
  filter_monitors = inter_biips('get_filter_monitor', id )
 \end{lstlisting}

 \texttt{GET\_FILTER\_MONITORS} dumps the filters monitors into the \texttt{filter\_monitors} double nested struct: for each monitored variable , we have
  a nested structure containing the following fields:
  \begin{itemize}
   \item \texttt{values}: matrix of vector of monitored values ( size: $N_{\mbox{space}} \times N_{\mbox{particules}}$)
   \item \texttt{weigths}: vector of weights (same dimensions as values)
   \item \texttt{ess}: vector of effective  sample size ( size: $N_{\mbox{space}}$)
   \item \texttt{discrete}: XXXXXX
   \item \texttt{name}: name of the variable
   \item \texttt{lower}: vector of lower bounds
   \item \texttt{upper}: vector of upper bounds
   \item \texttt{type}: string  'filtering'
   \end{itemize}

  For instance, if one wants to get all monitored values for variable \texttt{'x[1:4]'}, he could use
 \begin{lstlisting}
>> filter_monitors.('x[1:4]') 

ans = 

      values: [4x100 double]
     weights: [4x100 double]
         ess: [4x1 double]
    discrete: [4x1 double]
        name: 'x'
       lower: 1
       upper: 4
        type: 'filtering'
 
 \end{lstlisting}

 \section{get\_gen\_tree\_smooth\_monitors}
 
 \begin{lstlisting}
  smooth_monitors = inter_biips('get_gen_tree_smooth_monitors', id )
 \end{lstlisting}
 
 \texttt{GET\_GEN\_TREE\_SMOOTH\_MONITORS} dumps the smooth monitors into the \texttt{smooth\_monitors} double nested struct: for each monitored variable , we have
  a nested structure containing the following fields:

  \begin{itemize}
   \item \texttt{values}: matrix of vector of monitored values ( size: $N_{\mbox{space}} \times N_{\mbox{particules}}$)
   \item \texttt{weigths}: vector of weights (same dimensions as values)
   \item \texttt{ess}: vector of effective  sample size ( size: $N_{\mbox{space}}$)
   \item \texttt{discrete}: XXXXXX
   \item \texttt{name}: name of the variable
   \item \texttt{lower}: vector of lower bounds
   \item \texttt{upper}: vector of upper bounds
   \item \texttt{type}: string 'smoothing' 
   \end{itemize}

  For instance, if one wants to get all monitored values for variable \texttt{'x[1:4]'}, he could use
 \begin{lstlisting}
>> smooth_monitors.('x[1:4]')

ans = 

      values: [4x100 double]
     weights: [4x100 double]
         ess: [4x1 double]
    discrete: [4x1 double]
        name: 'x'
       lower: 1
       upper: 4
        type: 'smoothing'
 \end{lstlisting}

 \section{get\_backward\_smooth\_monitors}
 
 \begin{lstlisting}
  backward_smooth_monitors = inter_biips('get_backward_smooth_monitors', id )
 \end{lstlisting}
 
 \texttt{GET\_BACKWARD\_SMOOTH\_MONITORS} dumps the backward smooth monitors into the \texttt{backward\_smooth\_monitors} double nested struct: for each monitored variable , we have
  a nested structure containing the following fields:

  \begin{itemize}
   \item \texttt{values}: matrix of vector of monitored values ( size: $N_{\mbox{space}} \times N_{\mbox{particules}}$)
   \item \texttt{weigths}: vector of weights (same dimensions as values)
   \item \texttt{ess}: vector of effective  sample size ( size: $N_{\mbox{space}}$)
   \item \texttt{discrete}: XXXXXX
   \item \texttt{name}: name of the variable
   \item \texttt{lower}: vector of lower bounds
   \item \texttt{upper}: vector of upper bounds
   \item \texttt{type}: string 'backward\_smoothing'
   \end{itemize}

  For instance, if one wants to get all monitored values for variable \texttt{'x[1:4]'}, he could use
 \begin{lstlisting}
>> backward_smooth_monitors.('x[1:4]')

ans = 

      values: [4x100 double]
     weights: [4x100 double]
         ess: [4x1 double]
    discrete: [4x1 double]
        name: 'x'
       lower: 1
       upper: 4
        type: 'backward_smoothing'

 \end{lstlisting}

\section{clear\_filter\_monitors}
 
 \begin{lstlisting}
  inter_biips('clear_filter_monitors', id , release) 
 \end{lstlisting}
  
  \texttt{CLEAR\_FILTER\_MONITORS} removes all filter monitor relative to the console \texttt{id}: you can set the flag \texttt{release} to XXXXX

\section{clear\_gen\_tree\_smooth\_monitors}
 
 \begin{lstlisting}
  inter_biips('clear_gen_tree_smooth_monitors', id , release) 
 \end{lstlisting}
  
  \texttt{CLEAR\_GEN\_TREE\_MONITORS} removes all smooth monitors relative to the console \texttt{id}: you can set the flag \texttt{release} to XXXXX

\section{clear\_backward\_smooth\_monitors}
 
 \begin{lstlisting}
  inter_biips('clear_backward_smooth_monitors', id , release) 
 \end{lstlisting}
  
  \texttt{CLEAR\_BACKWARD\_SMOOTH\_MONITORS} removes all bac backward smooth monitors relative to the console \texttt{id}: you can set the flag \texttt{release} to XXXXX

\section{run\_backward\_smoother} 
 

 \begin{lstlisting}
  ok = inter_biips('run_backward_smoother', id) 
 \end{lstlisting}
  
  \texttt{RUN\_BACKWARD\_SMOOTHER} run the backward smoother algorithm relative to the console \texttt{id}


\section{get\_sorted\_nodes}

 
 \begin{lstlisting}
  sort_nodes= inter_biips('get_sorted_nodes, id)
 \end{lstlisting}
  \texttt{GET\_SORTED\_NODES} retrieves a struct \texttt{sort\_nodes} containing the following fields  
  \begin{itemize}
   \item \texttt{id}: vector of number for nodes
   \item \texttt{names}: cell of strings containing the names of nodes
   \item \texttt{type}: cell of strings containing the type of nodes \texttt{'Stochastic', 'Constant', 'Logical'}
   \item \texttt{observed}: vector of boolean flags to indicate if the node is observed or not  
   \end{itemize}

\section{get\_nodes\_samplers}

 \begin{lstlisting}
  nodes_samplers = inter_biips('get_nodes_samplers, id)
 \end{lstlisting}
  
  \texttt{GET\_NODES\_SAMPLERS} retrieves a struct \texttt{nodes\_samplers} containing the following fields:

  \begin{itemize}
   \item \texttt{iteration}: vector of integers contaning the numbers of iterations for each node
   \item \texttt{sampler}: cell of strings containing the name of samplers (e.g \texttt{'Conjugate Normal (with known precision)'}) 
   \end{itemize}


\section{print\_graphviz}

 \begin{lstlisting}
   inter_biips('print_graphviz', id, filename)
 \end{lstlisting}
 
  \texttt{PRINT\_GRAPHVIZ} save a graphical represention of the model of console \texttt{id} in the dot file \texttt{filename}

\section{change\_data}

 \begin{lstlisting} 
 change_ok = inter_biips('change_data', id, var, lower, upper, values, flag)
 \end{lstlisting}

 \texttt{CHANGE\_DATA} changes the values of some variables in the model: one could use the following 
  arguments

  \begin{itemize}
   \item \texttt{id}: console id
   \item \texttt{var}: string name of the variable to change
   \item \texttt{lower}: vector of lower bounds for the variable to change 
   \item \texttt{upper}: vector of upper bounds for the variable to change 
   \item \texttt{values}: vector or matrix of new values 
   \item \texttt{flag}: XXXXX
   \end{itemize}

\section{sample\_data}

 \begin{lstlisting} 
 sampled_values = inter_biips('sample_data', id, var, lower, upper, seed)
 \end{lstlisting}

  \texttt{SAMPLE\_VALUES} samples values for some variables in the model \texttt{id}

  \begin{itemize}
   \item \texttt{id}: console id
   \item \texttt{var}: string name of the variable to sample 
   \item \texttt{lower}: vector of lower bounds for the variable to sample
   \item \texttt{upper}: vector of upper bounds for the variable to sample 
   \item \texttt{seed}: seed for random number generation 
   \item \texttt{samples\_values} : vector or matrices of sampled values
   \end{itemize}

   \section{get\_log\_prior\_density}

 \begin{lstlisting} 
  log_prior_density = inter_biips('get_log_prior_density', id, var, lower, upper)
 \end{lstlisting}
    \texttt{GET\_LOG\_PRIOR\_DENSITY} retrieves the log prior density of the model \texttt{id}

 \begin{itemize}
   \item \texttt{id}: console id
   \item \texttt{var}: string name of the variable to sample 
   \item \texttt{lower}: vector of lower bounds for the variable to sample
   \item \texttt{upper}: vector of upper bounds for the variable to sample 
   \item \texttt{log\_prior\_density} : scalar value of the log prior density 
   \end{itemize}

\section{is\_smc\_sampler\_at\_end}

 \begin{lstlisting} 
  ok = inter_biips('is_smc_sampler_at_end', id)
 \end{lstlisting}
 \texttt{IS\_SMC\_SAMPLER\_AT\_END} checks that the smc sampler algorithm associated to the console \texttt{id} is finish.


\section{message}
 
 \begin{lstlisting} 
  inter_biips('message', id, msg)
 \end{lstlisting}

  \texttt{MESSAGE} writes the string \texttt{msg} in the console \texttt{id}

\section{set\_log\_norm\_const}

 \begin{lstlisting} 
  inter_biips('set_log_norm_const', id, log_norm)
 \end{lstlisting}
  
  \texttt{SET\_LOG\_NORM\_CONST} sets the value of the log normalisation constant

\section{make\_progress\_bar}

 \begin{lstlisting} 
  bar_id = inter_biips('make_progress_bar', num, progress_string, name)
 \end{lstlisting}

 \texttt{MAKE\_PROGRESS\_BAR} builds a progress bar in the current output stream. arguments are the following
 \begin{itemize}
  \item \texttt{num} : the number max of iterations (ie 100\% value)
  \item \texttt{progress\_string} : one character string used for progression (e.g '*', '+' or 'x')
  \item \texttt{name} : string for the name of bar
  \item \texttt{bar\_id} : number of the bar, in the table of bars
  \end{itemize}

\section{clear\_progress\_bar}
 
 \begin{lstlisting} 
  inter_biips('clear_progress_bar', bar_id)
 \end{lstlisting}
  \texttt{CLEAR\_PROGRESS\_BAR} clears the bar \texttt{bar\_id}

\section{advance\_progress\_bar} 
 
 \begin{lstlisting} 
  inter_biips('advance_progress_bar', bar_id, count)
 \end{lstlisting}
 
 \texttt{ADVANCE\_PROGRESS\_BAR} make a progress of \texttt{count} units for the bar \texttt{bar\_id} 


\section{is\_gen\_tree\_smooth\_monitored}

 \begin{lstlisting} 
  ok = inter_biips('is_gen_tree_smooth_monitored', id, names, lower, upper, check_released)
 \end{lstlisting}

\texttt{IS\_GEN\_TREE\_SMOOTH\_MONITORED} checks that smooth monitoring of some variable is finished: arguments are the following
 
 \begin{itemize}
  \item \texttt{id} : id of the console
  \item \texttt{names} : cell of strings indicating variables to check
  \item \texttt{lower} : cell of integers indicating lower bounds in variable monitoring
  \item \texttt{upper} : cell of integers indicating upper bounds in variable monitoring
  \item \texttt{check\_released} : boolean flag  indicating XXXX
 \end{itemize}


\section{sample\_gen\_tree\_smooth\_particle}

 \begin{lstlisting} 
  inter_biips('sample_gen_tree_smooth_particle', id, seed)
 \end{lstlisting}

 \texttt{SAMPLE\_GEN\_TREE\_SMOOTH\_PARTICLE} samples the values of the smooth monitors using \texttt{seed} for random number generation

\section{get\_sampled\_gen\_tree\_smooth\_particle}
 \begin{lstlisting} 
  sampled_value = inter_biips('get_sampled_gen_tree_smooth_particle', id)
 \end{lstlisting}

 \texttt{GET\_SAMPLED\_GEN\_TREE\_SMOOTH\_PARTICLE} retrieves the sample values of smooth monitor in a structure which has for fields the names
 of monitored variables.

\section{set\_sampled\_gen\_tree\_smooth\_particle}

 \begin{lstlisting} 
  sampled_value = inter_biips('set_sampled_gen_tree_smooth_particle', id, sampled_values)
 \end{lstlisting}

\section{weighted\_quantiles}

 \begin{lstlisting} 
  quantiles = inter_biips('weighted_quantiles', values, weights, probs)
 \end{lstlisting}

 \texttt{WEIGHTED\_QUANTILES} computes the weigthed quantiles using Boost accumulator


\section{cell2struct\_weak\_names}

 \begin{lstlisting} 
  weak_cell = inter_biips('weighted_quantiles', values, names)
 \end{lstlisting}

  \texttt{CELL2STRUCT\_WEAK\_NAMES} does the same jobs as \texttt{cell2struct} - build a struct from 2 cell arrays - but names of fields could be
  illegals, i.e.  names containing \texttt{[,:,]}

\section{add\_function}

 \begin{lstlisting} 
  inter_biips('add_function', name_func, nb_args, name_fun_dim, name_fun_eval, name_fun_check, name_fun_discrete) 
 \end{lstlisting}
 
 \texttt{ADD\_FUNCTION} adds a matlab function in the functions table. After that, the user could use the function in BUGS model. The arguments are the following

 \begin{itemize}
  \item \texttt{name\_func} : name of the function in bug models
  \item \texttt{nb\_args} : number of arguments of the function 
  \item \texttt{name\_fun\_dim} : name of the M-file function checking the size of arguments and returning a vector of dimensions of the output
  \item \texttt{name\_fun\_eval} : name of the M-file function which computes the value of the function
  \item \texttt{name\_fun\_check} : name of the M-file function checking the arguments
  \item \texttt{name\_fun\_discrete} : name of the M-file function which returns a boolean indicating the discretness of the output parameter of \texttt{add\_function}
\end{itemize}

\end{document}
